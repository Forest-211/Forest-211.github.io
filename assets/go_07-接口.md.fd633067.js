import{o as n,c as s,b as a}from"./app.ee89e8a3.js";const t='{"title":"接口","description":"","frontmatter":{},"headers":[{"level":2,"title":"定义","slug":"定义"},{"level":2,"title":"赋值","slug":"赋值"},{"level":3,"title":"将实现接口的对象实例赋值给接口","slug":"将实现接口的对象实例赋值给接口"},{"level":3,"title":"将接口赋值给接口","slug":"将接口赋值给接口"},{"level":2,"title":"查询","slug":"查询"},{"level":2,"title":"组合","slug":"组合"},{"level":2,"title":"值","slug":"值"},{"level":2,"title":"常见应用","slug":"常见应用"},{"level":3,"title":"error接口","slug":"error接口"},{"level":3,"title":"类型推断","slug":"类型推断"}],"relativePath":"go/07-接口.md","lastUpdated":1627858287904}',p={},o=a('<h1 id="接口"><a class="header-anchor" href="#接口" aria-hidden="true">#</a> 接口</h1><h2 id="定义"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h2><p>接口类型是对其他类型行为的概括与抽象。接口是Go语言最重要的特性之一。接口类型定义了一组方法，但是不包含这些方法的具体实现</p><p>接口本质上是一种类型，确切地说，是指针类型。接口可以实现多台功能。如果一个类型实现了某个接口，则所有使用这个接口的地方都支持这种类型的值。接口定义格式如下：</p><div class="language-go"><pre><code><span class="token keyword">type</span> 接口名称 <span class="token keyword">interface</span> <span class="token punctuation">{</span>\n  <span class="token function">method</span><span class="token punctuation">(</span>参数列表<span class="token punctuation">)</span> 返回值列表\n  <span class="token function">method2</span><span class="token punctuation">(</span>参数列表<span class="token punctuation">)</span> 返回值列表\n  <span class="token operator">...</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>如果接口没有方法声明，则它就是一个空接口（<code>interface{}</code>）。它的用途类似面向对象里的跟类型，可悲赋值为任何类型的对象。接口变量默认值是<code>nil</code>。如果实现接口的类型支持相等运算，则可做相等运算，否则报错。如下示例代码：</p><div class="language-go"><pre><code><span class="token keyword">package</span> main\n\n<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>\n\n<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t<span class="token keyword">var</span> var1<span class="token punctuation">,</span> var2 <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span>\n\tfmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>var1 <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">,</span> var1 <span class="token operator">==</span> var2<span class="token punctuation">)</span> <span class="token comment">// true true</span>\n\n\tvar1<span class="token punctuation">,</span> var2 <span class="token operator">=</span> <span class="token number">66</span><span class="token punctuation">,</span> <span class="token number">88</span>\n\tfmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>var1 <span class="token operator">==</span> var2<span class="token punctuation">)</span> <span class="token comment">// false</span>\n\n\tvar1<span class="token punctuation">,</span> var2 <span class="token operator">=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token punctuation">}</span>\n\tfmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>var1 <span class="token operator">==</span> var2<span class="token punctuation">)</span> <span class="token comment">// 报错</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h2 id="赋值"><a class="header-anchor" href="#赋值" aria-hidden="true">#</a> 赋值</h2><p>Go语言的接口不支持直接实例化，但支持赋值操作，从而快速实现接口与实现类的映射。接口赋值在Go语言中氛围两种情况：</p><ul><li>将实现接口的对象实例赋值给接口</li><li>将一个接口赋值给另一个接口</li></ul><h3 id="将实现接口的对象实例赋值给接口"><a class="header-anchor" href="#将实现接口的对象实例赋值给接口" aria-hidden="true">#</a> 将实现接口的对象实例赋值给接口</h3><p>将指定类型的对象实例赋值给接口，要求该对象对应的类实现了接口要求的所有方法，否则就不能算作接口的实现，例如，先定义一个<code>Num</code>类型及相关方法：</p><div class="language-"><pre><code>package main\n\nfunc main() {\n\n}\n\ntype Num int\n\n// 相等\nfunc (x Num) Equal(i Num) bool {\n\treturn x == i\n}\n\n// 小于\nfunc (x Num) LessThan(i Num) bool {\n\treturn x &lt; i\n}\n\n// 大于\nfunc (x Num) MoreThan(i Num) bool {\n\treturn x &gt; i\n}\n\n// 乘积\nfunc (x Num) Multiple(i Num) {\n\t*x = *x * i\n}\n\n// 相除\nfunc (x Num) Divide(i Num) {\n\t*x = *x / i\n}\n</code></pre></div><p>然后，相应地定义一个接口<code>NumI</code>，使其<code>Num</code>类型实现了<code>NumI</code>接口</p><div class="language-go"><pre><code><span class="token keyword">type</span> NumI <span class="token keyword">interface</span> <span class="token punctuation">{</span>\n\t<span class="token function">Equal</span><span class="token punctuation">(</span>i Num<span class="token punctuation">)</span> <span class="token builtin">bool</span>\n\t<span class="token function">LessThan</span><span class="token punctuation">(</span>i Num<span class="token punctuation">)</span> <span class="token builtin">bool</span>\n\t<span class="token function">MoreThan</span><span class="token punctuation">(</span>i Num<span class="token punctuation">)</span> <span class="token builtin">bool</span>\n\t<span class="token function">Multiple</span><span class="token punctuation">(</span>i Num<span class="token punctuation">)</span>\n\t<span class="token function">Divide</span><span class="token punctuation">(</span>i Num<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h3 id="将接口赋值给接口"><a class="header-anchor" href="#将接口赋值给接口" aria-hidden="true">#</a> 将接口赋值给接口</h3><p>在Go语言中，只要两个接口拥有相同的方法列表（与顺序无关），则他们就是等同的，可以相互赋值。比如下面两个包：</p><div class="language-go"><pre><code><span class="token keyword">package</span> oop1\n\n<span class="token keyword">type</span> NumInterface1 <span class="token keyword">interface</span> <span class="token punctuation">{</span>\n  <span class="token function">Equal</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span>\n  <span class="token function">LassThan</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span>\n  <span class="token function">BiggerThan</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span>\n<span class="token punctuation">}</span>\n</code></pre></div><div class="language-go"><pre><code><span class="token keyword">package</span> oop2\n\n<span class="token keyword">type</span> NumInterface1 <span class="token keyword">interface</span> <span class="token punctuation">{</span>\n  <span class="token function">Equal</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span>\n  <span class="token function">LassThan</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span>\n  <span class="token function">BiggerThan</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>上面两段代码只是包名、接口名和顺序不同，在Go语言中，上面两个接口实际上并无区别，因为<code>oop1</code>包的<code>NumInterface1</code>接口也实现了包名<code>oop2</code>的<code>NumInterface2</code>的所有方法，任何实现了以上两个接口的其中一个接口，那么就可以赋值给另一个接口</p><h2 id="查询"><a class="header-anchor" href="#查询" aria-hidden="true">#</a> 查询</h2><p>接口的查询是在程序运行时进行的。查询成功与否，也要在运行期才能够确定。它不像接口的赋值编译器只需要通过静态类型检查即可判断类型赋值是否可行。在Go语言中，可以询问它指向的对象是否是某个类型，例如：</p><div class="language-go"><pre><code><span class="token keyword">var</span> filewriter Writer <span class="token operator">=</span> <span class="token operator">...</span>\n<span class="token keyword">if</span> file<span class="token punctuation">,</span> ok <span class="token operator">:=</span> filewriter<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token operator">*</span>File<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>上面代码中的<code>if</code>语句用于判断<code>filewriter</code>接口只想的对戏那个实例是否为<code>*File</code>类型，如果是则执行特定的代码。接口的查询示例如下：</p><div class="language-go"><pre><code>slice <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>\nslice <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>slice<span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span>\n\n<span class="token keyword">var</span> I <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">=</span> slice\n\n<span class="token keyword">if</span> res<span class="token punctuation">,</span> ok <span class="token operator">:=</span> I<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span>\n  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token comment">// [6, 7, 8]</span>\n  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>ok<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>上面代码中的<code>if</code>语句会判断接口<code>I</code>所指向的对戏那个是否是<code>[]int</code>类型，如果是则输入切片中的元素。</p><h2 id="组合"><a class="header-anchor" href="#组合" aria-hidden="true">#</a> 组合</h2><p>在Go语言中，不仅结构体于结构体之间可以嵌套，接口与接口间也可以通过嵌套创造出新的接口。一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样呢。如果接口的所有方法被实现，则这个接口中的所有嵌套接口的方法均可以被调用</p><p>接口的组合很简单，直接将接口名写入接口内部即可；另外，还可以在接口内再定义自己的接口方法</p><div class="language-go"><pre><code><span class="token comment">// 接口1</span>\n<span class="token keyword">type</span> Interface1 <span class="token keyword">interface</span> <span class="token punctuation">{</span>\n  <span class="token function">Write</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 接口2</span>\n<span class="token keyword">type</span> Interfac2 <span class="token keyword">interface</span> <span class="token punctuation">{</span>\n  <span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 接口组合</span>\n<span class="token keyword">type</span> IncerfaceCombine <span class="token keyword">interface</span> <span class="token punctuation">{</span>\n  Interface1\n  Interface2\n<span class="token punctuation">}</span>\n</code></pre></div><p>上面代码就定义三个接口，其中<code>InterfaceCombine</code>接口就是一个组合接口，同时拥有了<code>Interface1</code>和<code>Interface2</code>两个接口的特性</p><h2 id="值"><a class="header-anchor" href="#值" aria-hidden="true">#</a> 值</h2><p>一个接口类型的值（简称接口值）有两部分组成：</p><ul><li>具体类型（动态类型）</li><li>类型的值（动态值）</li></ul><p>在Go语言中，类型仅仅是编译时的概念，所以类型不是一个值，类型描述符可以提供每一个类型的具体信息，比如他的名字和方法等。对于一个接口值，类型部分一般用对应的类型描述符来表达</p><p>如果接口值的零值是<code>nil</code>，则它的动态值为<code>nil</code>。一个接口值是否为<code>nil</code> 取决于他的动态类型。我们可以使用<code>xx != nil</code>或者<code>xx == nil</code> 做判断，如果在<code>nil</code>上调用了一个方法，则会让程序崩溃</p><h2 id="常见应用"><a class="header-anchor" href="#常见应用" aria-hidden="true">#</a> 常见应用</h2><h3 id="error接口"><a class="header-anchor" href="#error接口" aria-hidden="true">#</a> error接口</h3><p>在Go语言中，<code>error</code>接口的定义如下：</p><div class="language-go"><pre><code><span class="token keyword">type</span> <span class="token builtin">error</span> <span class="token keyword">interface</span> <span class="token punctuation">{</span>\n\t<span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">type</span> errorString <span class="token keyword">struct</span> <span class="token punctuation">{</span>\n\ts <span class="token builtin">string</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">func</span> <span class="token function">New</span><span class="token punctuation">(</span>text <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>\n\t<span class="token keyword">return</span> <span class="token operator">&amp;</span>errorString<span class="token punctuation">{</span>text<span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">func</span> <span class="token punctuation">(</span>e <span class="token operator">*</span>errorString<span class="token punctuation">)</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>\n\t<span class="token keyword">return</span> e<span class="token punctuation">.</span>s\n<span class="token punctuation">}</span>\n</code></pre></div><p>上面代码中，定义了一个<code>errorString</code>结构体，内部只有一个<code>s</code>成员且类型为<code>string</code></p><p>实现<code>Error</code>方法的是<code>*errorString</code>指针，不是类型<code>errorString</code>。它的目的是在调用<code>New</code>函数时分配的<code>error</code>实例变量都不相等</p><h3 id="类型推断"><a class="header-anchor" href="#类型推断" aria-hidden="true">#</a> 类型推断</h3><p>类型推断的写法如下：</p><div class="language-go"><pre><code>i<span class="token punctuation">.</span><span class="token punctuation">(</span>Type<span class="token punctuation">)</span>\n</code></pre></div><ul><li><code>i</code>是一个接口类型的表达式</li><li><code>Type</code>是一个类型</li></ul><p>类型推断会检查<code>i</code>的动态类型是否满足指定的<code>Type</code>类型。如果<code>i</code>是空值，则类型推断会失败</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>当<code>Type</code>是一个具体类型时，那么就会推断<code>i</code>的动态类型是否时<code>Type</code>；如果检查成功，则断言的结果为<code>i</code>的动态类型是<code>Type</code>；检查失败则程序崩溃</p><p>如果<code>Type</code>是一个接口的类型时，那么就会推断<code>i</code>的动态类型是否是<code>Type</code>。如果检查成功，则动态值没有获取成功，结果是一个接口值。接口值和值的类型没有变化，只是结果的类型为接口类型<code>Type</code></p></div><p>类型推断可将接口变量还原为原始类型，或用来判断是否实现了某个更具体的接口类型。还可以用<code>switch-case</code>(也叫类型分支)语句再多种类型间做推断匹配，这样空接口就有更多的发挥空间</p><div class="language-go"><pre><code><span class="token keyword">package</span> main\n\n<span class="token keyword">import</span> <span class="token string">&quot;fmt&quot;</span>\n\n<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t<span class="token keyword">var</span> a <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>a <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>\n\t\t<span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">&quot;d:%d&quot;</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span>\n\t<span class="token punctuation">}</span>\n\t<span class="token keyword">switch</span> b <span class="token operator">:=</span> a<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t<span class="token keyword">case</span> <span class="token boolean">nil</span><span class="token punctuation">:</span>\n\t\tfmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;nil&quot;</span><span class="token punctuation">)</span>\n\t<span class="token keyword">case</span> <span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">:</span>\n\t\tfmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;int类型：&quot;</span><span class="token punctuation">,</span> <span class="token operator">*</span>b<span class="token punctuation">)</span>\n\t<span class="token keyword">case</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">string</span><span class="token punctuation">:</span>\n\t\tfmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token number">1234</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n\t<span class="token keyword">case</span> fmt<span class="token punctuation">.</span>Stringer<span class="token punctuation">:</span>\n\t\tfmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>\n\t<span class="token keyword">default</span><span class="token punctuation">:</span>\n\t\tfmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">&quot;unkown&quot;</span><span class="token punctuation">)</span>\n\t<span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 最后输出结果为：d:1234</span>\n</code></pre></div>',50);p.render=function(a,t,p,e,c,u){return n(),s("div",null,[o])};export default p;export{t as __pageData};
