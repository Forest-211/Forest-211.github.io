import{o as n,c as s,d as a}from"./app.e55fc591.js";const t='{"title":"面试题","description":"","frontmatter":{"title":"面试题"},"headers":[{"level":2,"title":"keep-alive  组件有什么作用？","slug":"keep-alive-组件有什么作用？"},{"level":2,"title":"说下 vue 生命周期钩子函数?","slug":"说下-vue-生命周期钩子函数"},{"level":2,"title":"Vue 中 computed 和 watch 区别?","slug":"vue-中-computed-和-watch-区别"},{"level":2,"title":"React 的组件间通信都有哪些形式？","slug":"react-的组件间通信都有哪些形式？"},{"level":2,"title":"React 中如何实现路由懒加载？","slug":"react-中如何实现路由懒加载？"},{"level":2,"title":"React 的生命周期函数都有哪些，分别有什么作用？","slug":"react-的生命周期函数都有哪些，分别有什么作用？"},{"level":2,"title":"说一下 React Hooks 在平时开发中需要注意的问题和原因?","slug":"说一下-react-hooks-在平时开发中需要注意的问题和原因"},{"level":2,"title":"Token 一般是存放在哪里? Token 放在 cookie 和放在 localStorage、sessionStorage 中有什么不同?","slug":"token-一般是存放在哪里-token-放在-cookie-和放在-localstorage、sessionstorage-中有什么不同"},{"level":2,"title":"WebSocket 是怎么实现点对点通信和广播通信的？","slug":"websocket-是怎么实现点对点通信和广播通信的？"},{"level":2,"title":"客户端缓存有几种方式?浏览器出现 from disk、from memory 的 策略是啥?","slug":"客户端缓存有几种方式-浏览器出现-from-disk、from-memory-的-策略是啥"},{"level":2,"title":"说一下 CORS 的简单请求和复杂请求的区别?","slug":"说一下-cors-的简单请求和复杂请求的区别"},{"level":2,"title":"节流和防抖分别是什么？在什么场景下使用？请分别实现一个节流函数和一个防抖函数","slug":"节流和防抖分别是什么？在什么场景下使用？请分别实现一个节流函数和一个防抖函数"},{"level":2,"title":"怎么禁止让 js 读取 cookie？怎么让 cookie 只在 HTTPS 下传输？","slug":"怎么禁止让-js-读取-cookie？怎么让-cookie-只在-https-下传输？"},{"level":2,"title":"v-if 和 v-for 为什么不能连用？","slug":"v-if-和-v-for-为什么不能连用？"},{"level":2,"title":"单页面应用和多页面应用区别及优缺点?","slug":"单页面应用和多页面应用区别及优缺点"},{"level":2,"title":"v-model  该如何实现？","slug":"v-model-该如何实现？"},{"level":2,"title":"vue2 中为什么检测不到数组的变化，如何解决?","slug":"vue2-中为什么检测不到数组的变化，如何解决"},{"level":2,"title":"在 React 项目中，想要进行逻辑复用,有哪些方案？","slug":"在-react-项目中，想要进行逻辑复用-有哪些方案？"},{"level":3,"title":"组件逻辑复用、组件视图复用","slug":"组件逻辑复用、组件视图复用"},{"level":2,"title":"在 React 中，针对类组件 和 函数组件，分别怎么去进行性能优化？","slug":"在-react-中，针对类组件-和-函数组件，分别怎么去进行性能优化？"},{"level":2,"title":"Vue3 中 Teleport 的作用是什么","slug":"vue3-中-teleport-的作用是什么"},{"level":3,"title":"teleport 可以包含 vue 组件使用么？","slug":"teleport-可以包含-vue-组件使用么？"},{"level":3,"title":"可以使用多个 teleport 指向同一标签么？","slug":"可以使用多个-teleport-指向同一标签么？"},{"level":2,"title":"说一下 vue3 的 composition api?","slug":"说一下-vue3-的-composition-api"},{"level":3,"title":"composition api 是强制使用的么？我还可以在 vue3 中使用 options api 的方式进行开发么？","slug":"composition-api-是强制使用的么？我还可以在-vue3-中使用-options-api-的方式进行开发么？"},{"level":3,"title":"我还可以在 setup 中通过 this 来使用实例上的属性么？","slug":"我还可以在-setup-中通过-this-来使用实例上的属性么？"},{"level":2,"title":"vue3 中 v-model 的变化?","slug":"vue3-中-v-model-的变化"},{"level":3,"title":"是否还可以使用 vue2 版本的方式配置 model 名称？","slug":"是否还可以使用-vue2-版本的方式配置-model-名称？"},{"level":3,"title":"在同一个组件上绑定多个 v-model 时需不需要单独进行配置？","slug":"在同一个组件上绑定多个-v-model-时需不需要单独进行配置？"},{"level":2,"title":"说一下 Vue3 与 Vue2 的对比？","slug":"说一下-vue3-与-vue2-的对比？"},{"level":2,"title":"在组件的通信中 EventBus 非常经典，你能手写实现下 EventBus 么？","slug":"在组件的通信中-eventbus-非常经典，你能手写实现下-eventbus-么？"},{"level":2,"title":"请介绍一下装饰者模式，并实现？","slug":"请介绍一下装饰者模式，并实现？"},{"level":2,"title":"了解 js 中设计模式吗？动手实现一下单例模式？","slug":"了解-js-中设计模式吗？动手实现一下单例模式？"},{"level":2,"title":"虚拟  DOM  有什么作用，如何构建虚拟 DOM？","slug":"虚拟-dom-有什么作用，如何构建虚拟-dom？"},{"level":2,"title":"你对浏览器的理解？","slug":"你对浏览器的理解？"},{"level":2,"title":"介绍一下你对浏览器内核的理解？","slug":"介绍一下你对浏览器内核的理解？"},{"level":2,"title":"常见的浏览器内核比较","slug":"常见的浏览器内核比较"},{"level":2,"title":"extend 能做什么","slug":"extend-能做什么"},{"level":2,"title":"mixin 和 mixins 区别","slug":"mixin-和-mixins-区别"},{"level":2,"title":"响应式原理","slug":"响应式原理"},{"level":2,"title":"二、Vue3 中的数据响应式是怎么实现的？","slug":"二、vue3-中的数据响应式是怎么实现的？"},{"level":2,"title":"请简述 Vue 中 Template 的实现思路？","slug":"请简述-vue-中-template-的实现思路？"},{"level":2,"title":"如何把真实 dom 转变为虚拟 dom，代码实现一下？","slug":"如何把真实-dom-转变为虚拟-dom，代码实现一下？"}],"relativePath":"interview/index.md","lastUpdated":1620437055731}',p={},o=a('<h2 id="keep-alive-组件有什么作用？"><a class="header-anchor" href="#keep-alive-组件有什么作用？" aria-hidden="true">#</a> keep-alive  组件有什么作用？</h2><blockquote><p>主要用于保留组件状态或避免重新渲染。 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。</p></blockquote><h2 id="说下-vue-生命周期钩子函数"><a class="header-anchor" href="#说下-vue-生命周期钩子函数" aria-hidden="true">#</a> 说下 vue 生命周期钩子函数?</h2><blockquote><p>-Vue 实例创建阶段的生命周期函数</p><ul><li>初始化事件及生命周期函数 <ul><li>brforeCreate() ---------- data 和 methods 中的数据都还没有初始化</li><li>创建中，正在初始化 data 和 methods</li><li>Created() -------------- 如果需要操作 data 中的数据或操作方法，可以放在这个函数里</li></ul></li><li>开始编译模板 <ul><li>beforeMount() --------- 模板编译好了，但是还没有放到页面中去 - 把编译好的模板放到浏览器中去进行渲染</li><li>mounted() ------------- 页面渲染完成，Vue 实例初始化完毕</li></ul></li><li>Vue 实例运行阶段的生命周期函数 <ul><li>如果数据发生改变 <ul><li>beforeUpdate() -------- 页面数据还没有更新，但是 data 中的数据已经更新完毕，页面与数据不同步</li></ul></li><li>Diff, 这一步执行，是先根据 data 中的最新数据，在内存中重新计算出一份 dom 树，对比新老两个 dom 树之间的差异... <ul><li>update() ---------------- 这时候，数据和页面已经完成更新</li></ul></li></ul></li><li>Vue 实例销毁阶段的生命周期函数 <ul><li>beforeDestroy() -------- 销毁执行之前，实例身上所有的数据和事件，指令等等都可以用，此刻还没有真正执行销毁</li><li>destroyed() ------------- 执行这个函数的时候，组件中的数据，方法，指令，过滤器等等完全销毁</li></ul></li></ul></blockquote><h2 id="vue-中-computed-和-watch-区别"><a class="header-anchor" href="#vue-中-computed-和-watch-区别" aria-hidden="true">#</a> Vue 中 computed 和 watch 区别?</h2><blockquote><ul><li>computed  是计算属性，依赖其他属性计算值，并且 computed  的值有缓存，只有当计算值变化才会返回内容。</li><li>watch  监听到值的变化就会执行回调，在回调中可以进行一些逻辑操作。</li></ul></blockquote><h2 id="react-的组件间通信都有哪些形式？"><a class="header-anchor" href="#react-的组件间通信都有哪些形式？" aria-hidden="true">#</a> React 的组件间通信都有哪些形式？</h2><blockquote><ul><li>父传子：在 React 中，父组件调用子组件时可以将要传递给子组件的数据添加在子组件的属性中，在子组件中通过 props 属性进行接收。这个就是父组件向子组件通信。</li><li>子传父：React 是单向数据流，数据永远只能自上向下进行传递。当子组件中有些数据需要向父级进行通信时，需要在父级中定义好回调，将回调传递给子组件，子组件调用父级传递过来的回调方法进行通信。</li><li>跨组件通信 - context。使用 context API，可以在组件中向其子孙级组件进行信息传递。</li></ul></blockquote><h2 id="react-中如何实现路由懒加载？"><a class="header-anchor" href="#react-中如何实现路由懒加载？" aria-hidden="true">#</a> React 中如何实现路由懒加载？</h2><p>在 React 16 中，新增了 lazy 方法，通过 lazy 方法可以轻松实现组件懒加载，当然要实现路由懒加载的话，其实也只需要把路由组件结合 lazy 使用即可。   参考代码如下：</p><div class="language-javascript"><pre><code><span class="token keyword">import</span> <span class="token punctuation">{</span> Route <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;react-router-dom&#39;</span>\n<span class="token keyword">import</span> React<span class="token punctuation">,</span> <span class="token punctuation">{</span> Suspense <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;react&#39;</span>\n<span class="token keyword">const</span> HomeView <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">lazy</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">&#39;./home&#39;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>\n        <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>\n            <span class="token operator">&lt;</span>h1<span class="token operator">&gt;</span>路由懒加载<span class="token operator">&lt;</span><span class="token operator">/</span>h1<span class="token operator">&gt;</span>              \n            <span class="token operator">&lt;</span>Route\n                path<span class="token operator">=</span><span class="token string">&quot;/&quot;</span>\n                exact\n                render<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n                    <span class="token keyword">return</span> <span class="token punctuation">(</span>\n                        <span class="token operator">&lt;</span>Suspense\n                            fallback<span class="token operator">=</span><span class="token punctuation">{</span><span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>组件Loading进来之前的占位内容<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span><span class="token punctuation">}</span>\n                        <span class="token operator">&gt;</span>\n                                          \n                            <span class="token operator">&lt;</span>HomeView <span class="token operator">/</span><span class="token operator">&gt;</span>\n                                  \n                        <span class="token operator">&lt;</span><span class="token operator">/</span>Suspense<span class="token operator">&gt;</span>\n                    <span class="token punctuation">)</span>\n                <span class="token punctuation">}</span><span class="token punctuation">}</span>\n            <span class="token operator">/</span><span class="token operator">&gt;</span>\n                       \n        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>\n    <span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> App\n</code></pre></div><p>在上述代码中使用 lazy 引入了一个动态组件，然后将该组件放入了根路由中。这样的话只有用户访问网站首页时，才会动态加载这个组件。注意在 React 规范中，lazy 和 Suspense 必须配合使用，lazy 引入的动态组件必须要放入 Suspense 中，Suspense 的 fallback 属性是 lazy 的组件没有加载进来之前的占位内容。</p><h2 id="react-的生命周期函数都有哪些，分别有什么作用？"><a class="header-anchor" href="#react-的生命周期函数都有哪些，分别有什么作用？" aria-hidden="true">#</a> React 的生命周期函数都有哪些，分别有什么作用？</h2><p>React 的生命周期已经经历了 3 次改动，最新的版本可以看下图：</p><blockquote><ul><li><p>挂载阶段：</p><ul><li>constructor: 初始化组件，初始化组件的 state 等。</li><li>static getDerivedStateFromProps()：该函数用于将 props 中的信息映射到 state 中。</li><li>render: 生成虚拟 DOM</li><li>componentDidMount：组件挂载完成，通过在该函数中去处理副作用 更新阶段：</li><li>static getDerivedStateFromProps()</li><li>shouldComponentUpdate()：该生命周期函数用于判断是否要进行组件更新。</li><li>render()：生成虚拟 DOM</li><li>getSnapshotBeforeUpdate()：组件已经完成 diff，即将更新真实 DOM，用户获取上一次的 DOM 快照。该函数必须搭配 componentDidUpdate 一块使用，返回值会变成 componentDidUpdate 第三个参数。</li><li>componentDidUpdate()： 组件更新完成，通常在该函数中进行副作用处理。</li></ul></li><li><p>即将卸载：</p><ul><li>componentWillUnmount：组件即将卸载，用于删除组件添加到全局的数据或事件。</li></ul></li></ul></blockquote><h2 id="说一下-react-hooks-在平时开发中需要注意的问题和原因"><a class="header-anchor" href="#说一下-react-hooks-在平时开发中需要注意的问题和原因" aria-hidden="true">#</a> 说一下 React Hooks 在平时开发中需要注意的问题和原因?</h2><ul><li>不要在循环，条件或嵌套函数中调用 Hook，必须始终在 React 函数的顶层使用 Hook</li></ul><p>这是因为 React 需要利用调用顺序来正确更新相应的状态，以及调用相应的钩子函数。一旦在循环或条件分支语句中调用 Hook，就容易导致调用顺序的不一致性，从而产生难以预料到的后果。</p><ul><li>使用 useState 时候，使用 push，pop，splice 等直接更改数组对象的坑</li></ul><p>使用 push 直接更改数组无法获取到新值，应该采用析构方式，但是在 class 里面不会有这个问题</p><p>代码示例</p><div class="language-javascript"><pre><code><span class="token keyword">function</span> <span class="token function">Indicatorfilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> <span class="token punctuation">[</span>num<span class="token punctuation">,</span> setNums<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n    <span class="token keyword">const</span> <span class="token function-variable function">test</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 这里坑是直接采用 push 去更新 num</span>\n        <span class="token comment">// setNums(num)是无法更新 num 的</span>\n        <span class="token comment">// 必须使用 num = [...num ,1]</span>\n        num<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>\n        <span class="token comment">// num = [...num ,1]</span>\n        <span class="token function">setNums</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>\n        <span class="token operator">&lt;</span>div className<span class="token operator">=</span><span class="token string">&quot;filter&quot;</span><span class="token operator">&gt;</span>\n            <span class="token operator">&lt;</span>div onClick<span class="token operator">=</span><span class="token punctuation">{</span>test<span class="token punctuation">}</span><span class="token operator">&gt;</span>测试<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>\n            <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>\n                <span class="token punctuation">{</span>num<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token punctuation">,</span> index</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>\n                    <span class="token operator">&lt;</span>div key<span class="token operator">=</span><span class="token punctuation">{</span>index<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>item<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>\n                <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>\n            <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>\n        <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>\n    <span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">class</span> <span class="token class-name">Indicatorfilter</span> <span class="token keyword">extends</span> <span class="token class-name">React<span class="token punctuation">.</span>Component</span><span class="token operator">&lt;</span>any<span class="token punctuation">,</span> any<span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">props<span class="token operator">:</span> any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">super</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> <span class="token punctuation">{</span>\n            nums<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>test <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// class 采用同样的方式是没有问题的</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>nums<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n            nums<span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span>nums\n        <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">let</span> <span class="token punctuation">{</span> nums <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>state\n        <span class="token keyword">return</span> <span class="token punctuation">(</span>\n            <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>\n                <span class="token operator">&lt;</span>div onClick<span class="token operator">=</span><span class="token punctuation">{</span><span class="token keyword">this</span><span class="token punctuation">.</span>test<span class="token punctuation">}</span><span class="token operator">&gt;</span>测试<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>\n                <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>\n                    <span class="token punctuation">{</span>nums<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item<span class="token operator">:</span> any<span class="token punctuation">,</span> index<span class="token operator">:</span> number</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>\n                        <span class="token operator">&lt;</span>div key<span class="token operator">=</span><span class="token punctuation">{</span>index<span class="token punctuation">}</span><span class="token operator">&gt;</span><span class="token punctuation">{</span>item<span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>\n                    <span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span>\n                <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>\n            <span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>\n        <span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><ul><li>useState 设置状态的时候，只有第一次生效，后期需要更新状态，必须通过 useEffect</li></ul><p>看下面的例子</p><p>TableDeail 是一个公共组件，在调用它的父组件里面，我们通过 set 改变 columns 的值，以为传递给 TableDeail 的 columns 是最新的值，所以 tabColumn 每次也是最新的值，但是实际 tabColumn 是最开始的值，不会随着 columns 的更新而更新</p><div class="language-javascript"><pre><code><span class="token keyword">const</span> <span class="token function-variable function">TableDeail</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> columns <span class="token punctuation">}</span><span class="token operator">:</span> TableData</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> <span class="token punctuation">[</span>tabColumn<span class="token punctuation">,</span> setTabColumn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span>columns<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 正确的做法是通过useEffect改变这个值</span>\n<span class="token keyword">const</span> <span class="token function-variable function">TableDeail</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> columns <span class="token punctuation">}</span><span class="token operator">:</span> TableData</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> <span class="token punctuation">[</span>tabColumn<span class="token punctuation">,</span> setTabColumn<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span>columns<span class="token punctuation">)</span>\n    <span class="token function">useEffect</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n        <span class="token function">setTabColumn</span><span class="token punctuation">(</span>columns<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>columns<span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre></div><ul><li>善用 useCallback</li></ul><p>父组件传递给子组件事件句柄时，如果我们没有任何参数变动可能会选用 useMemo。但是每一次父组件渲染子组件即使没变化也会跟着渲染一次。</p><ul><li>不要滥用 useContext</li></ul><p>可以使用基于 useContext 封装的状态管理工具。</p><h2 id="token-一般是存放在哪里-token-放在-cookie-和放在-localstorage、sessionstorage-中有什么不同"><a class="header-anchor" href="#token-一般是存放在哪里-token-放在-cookie-和放在-localstorage、sessionstorage-中有什么不同" aria-hidden="true">#</a> Token 一般是存放在哪里? Token 放在 cookie 和放在 localStorage、sessionStorage 中有什么不同?</h2><blockquote><ul><li>Token 其实就是访问资源的凭证。</li><li>一般是用户通过用户名和密码登录成功之后，服务器将登陆凭证做数字签名，加密之后得到的字符串作为 token。</li><li>它在用户登录成功之后会返回给客户端，客户端主要有这么几种存储方式：存储在 localStorage 中，每次调用接口的时候都把它当成一个字段传给后台存储在 cookie 中，让它自动发送，不过缺点就是不能跨域拿到之后存储在 localStorage 中，每次调用接口的时候放在 HTTP 请求头的 Authorization 字段里</li><li>所以 token 在客户端一般存放于 localStorage，cookie，或 sessionStorage 中。将 token 存放在 webStroage 中，可以通过同域的 js 来访问 。这样会导致很容易受到 xss 攻击，特别是项目中引入很多 第三方 js 类库的情况下。如果 js 脚本被盗用，攻击者就 可以轻易访问你的网站，webStroage 作为一种储存机制，在传输过程中不会执行任何安全标准。</li><li>XSS 攻击：cross-site Scripting（跨站脚本攻击）是一种注入代码攻击 。恶意攻击者在目标网站上注入 script 代码，当访问者浏览网站的时候通过执行注入的 script 代码达到窃取用户信息，盗用用户身份等。</li><li>将 token 存放在 cookie 中可以指定 httponly，来防止被 Javascript 读取，也可以指定 secure，来保证 token 只在 HTTPS 下传输。缺点是不符合 Restful 最佳实践，容易受到 CSRF 攻击。</li><li>CSRF 跨站点请求伪造(Cross—Site Request Forgery)，跟 XSS 攻击一样，存在巨大的危害性。简单来说就是恶意攻击者盗用已经认证过的用户信息，以用户信息名义进行一些操作（如发邮件、转账、购买商品等等）。由于身份已经认证过，所以目标网站会认为操作都是真正的用户操作的 。CSRF 并不能拿到用户信息，它只是盗用的用户凭证去进行操作。</li></ul></blockquote><h2 id="websocket-是怎么实现点对点通信和广播通信的？"><a class="header-anchor" href="#websocket-是怎么实现点对点通信和广播通信的？" aria-hidden="true">#</a> WebSocket 是怎么实现点对点通信和广播通信的？</h2><blockquote><p>webSocket 是一种全双工通信协议。websocket 让服务端和客户端通信变得简单。最大的特点是可以通过服务端主动推送消息到客户端。前端基于 nodejs 和 WebSocket 实现点对点及广播通信。</p><ul><li>广播通信顾名思义是类似广播一样给多个人进行广播消息。</li><li>点对点通信顾名思义就是一对一的通信，例如多人实时聊天，可以指定用户来发送消息。点对点通信中需要注意服务端需要记录每个 socket 客户端的连接 ，需要将客户端及服务端 socket 对象关联起来。广播数据的时候，广播指定对象就可以了</li><li>WebSocket 区分广播通信及点对点通信核心在于区分每一个连接的 socket 对象。广播通信需要对于非自身的所有连接的 socket 对象进行通信。而点对点通信，通过关联用户及 socket 对象，且保存每一个 socket 连接，查找指定的 socket 对象，来达到发送指定 socket 连接的目的。</li></ul></blockquote><h2 id="客户端缓存有几种方式-浏览器出现-from-disk、from-memory-的-策略是啥"><a class="header-anchor" href="#客户端缓存有几种方式-浏览器出现-from-disk、from-memory-的-策略是啥" aria-hidden="true">#</a> 客户端缓存有几种方式?浏览器出现 from disk、from memory 的 策略是啥?</h2><p>1.强缓存</p><ul><li>服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。</li><li><code>Cache-control</code> （相对值）、 <code>Expries</code>（绝对值）</li><li>Expries 是 http1.0 的标准</li></ul><div class="language-javascript"><pre><code><span class="token keyword">let</span> nowTime <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nnowTime<span class="token punctuation">.</span><span class="token function">setTime</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">3600</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span>\nctx<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&#39;Expires&#39;</span><span class="token punctuation">,</span> nowTime<span class="token punctuation">.</span><span class="token function">toUTCString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n</code></pre></div><p>到了<code>HTTP/1.1</code>，<code>Expire</code>已经被<code>Cache-Control</code>替代<code>ctx.set(&quot;Cache-control&quot;,&quot;max-age=3600&quot;) // 设置缓存时间 3600s</code></p><ul><li><p>public：所有内容都将被缓存（客户端和代理服务器都可缓存） - private：所有内容只有客户端可以缓存，<code>Cache-Control</code>的默认取值 - no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定 - no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存 - max-age=xxx ：缓存内容将在 xxx 秒后失效<code>Cache-Control</code>优先级比<code>Expires</code>高<code>from memory cache</code>代表使用内存中的缓存，<code>from disk cache</code>则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为<code>memory –&gt; disk</code>。</p></li><li><p>协商缓存让客户端与服务器之间能实现缓存文件是否更新的验证、提升缓存的复用率，将缓存信息中的<code>Etag</code>和<code>Last-Modified</code>通过请求发送给服务器，由服务器校验，返回 304 状态码时，浏览器直接使用缓存。出现<code> from disk</code>、<code>from memory</code> 的策略是强缓存。</p><ul><li>`Last-Modify/if-Modify-Since</li><li>ETag/if-None-Macth`</li><li>协商缓存的标识也是在响应报文的 HTTP 头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：<code>Last-Modified / If-Modified-Since</code>和<code>Etag / If-None-Match</code>，其中<code>Etag / If-None-Match</code>的优先级比<code>Last-Modified / If-Modified-Since</code>高。</li><li>缓存关系强缓存优于协商缓存，强缓存中 <code>Cache-control</code> 优于 <code>Expries</code>，协商缓存中<code>ETag/ If-None-Match</code> 优先级高于 <code>Last-Modified / If-Modified-Since</code>。</li></ul></li></ul><h2 id="说一下-cors-的简单请求和复杂请求的区别"><a class="header-anchor" href="#说一下-cors-的简单请求和复杂请求的区别" aria-hidden="true">#</a> 说一下 CORS 的简单请求和复杂请求的区别?</h2><ul><li><code>CORS(Cross-origin resource sharing)</code>，跨域资源共享，是一份浏览器技术的规范，用来避开浏览器的同源策略。相关头部设置如下： <ul><li><code>Access-Control-Allow-Origin</code> 指示请求的资源能共享给哪些域。 <code>Access-Control-Allow-Credentials</code> 指示当请求的凭证标记为 <code>true</code> 时，是否响应该请求。 <code>Access-Control-Allow-Headers</code> 用在对预请求的响应中，指示实际的请求中可以使用哪些 <code>HTTP</code> 头。 <code>Access-Control-Allow-Methods</code> 指定对预请求的响应中，哪些 <code>HTTP</code> 方法允许访问请求的资源。 <code>Access-Control-Expose-Headers</code> 指示哪些 <code>HTTP</code> 头的名称能在响应中列出。 <code>Access-Control-Max-Age</code> 指示预请求的结果能被缓存多久。 <code>Access-Control-Request-Headers</code> 用于发起一个预请求，告知服务器正式请求会使用那些 <code>HTTP</code> 头。 <code>Access-Control-Request-Method</code> 用于发起一个预请求，告知服务器正式请求会使用哪一种 <code>HTTP</code> 请求方法。 <code>Origin</code> 指示获取资源的请求是从什么域发起的。</li><li><code>CORS</code>可以分成两种简单请求和复杂请求。简单请求是满足以下下条件的请求</li><li>HTTP 方法是下列之一 <ul><li>HEAD</li><li>GET</li><li>POST</li></ul></li><li>HTTP 头信息不超出以下几种字段 <ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type，但仅能是下列之一</li><li>application/x-www-form-urlencoded</li><li>multipart/form-datatext/plain`</li></ul></li><li>反之就是复杂请求，复杂请求表面上看起来和简单请求使用上差不多，但实际上浏览器发送了不止一个请求。其中最先发送的是一种&quot;预请求&quot;，此时作为服务端，也需要返回&quot;预回应&quot;作为响应。预请求实际上是对服务端的一种权限请求，只有当预请求成功返回，实际请求才开始执行。</li></ul></li></ul><h2 id="节流和防抖分别是什么？在什么场景下使用？请分别实现一个节流函数和一个防抖函数"><a class="header-anchor" href="#节流和防抖分别是什么？在什么场景下使用？请分别实现一个节流函数和一个防抖函数" aria-hidden="true">#</a> 节流和防抖分别是什么？在什么场景下使用？请分别实现一个节流函数和一个防抖函数</h2><h2 id="怎么禁止让-js-读取-cookie？怎么让-cookie-只在-https-下传输？"><a class="header-anchor" href="#怎么禁止让-js-读取-cookie？怎么让-cookie-只在-https-下传输？" aria-hidden="true">#</a> 怎么禁止让 js 读取 cookie？怎么让 cookie 只在 HTTPS 下传输？</h2><blockquote><p>由于 cookie 会存放在客户端，一般情况下会保存一些凭证及状态信息，为了防止 cookie 泄露造成安全问题。可以这只 cookie 的 HttpOnly 属性，那么通过程序(JS 脚本、Applet 等)将无法读取到 Cookie 信息，这样能有效的防止 XSS 攻击。cookie 中有个属性 secure，当该属性设置为 true 时，表示创建的 Cookie 会被以安全的形式向服务器传输，也就是只能在 HTTPS 连接中被浏览器传递到服务器端进行会话验证，如果是 HTTP 连接则不会传递该 cookie 信息，所以不会被窃取到 Cookie 的具体内容。就是只允许在加密的情况下将 cookie 加在数据包请求头部，防止 cookie 被带出来。secure 属性是防止信息在传递的过程中被监听捕获后信息泄漏。但是这两个属性并不能解决 cookie 在本机出现的信息泄漏的问题。</p></blockquote><h2 id="v-if-和-v-for-为什么不能连用？"><a class="header-anchor" href="#v-if-和-v-for-为什么不能连用？" aria-hidden="true">#</a> v-if 和 v-for 为什么不能连用？</h2><blockquote><p>v-for 比 v-if 优先，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候 。可以采取多层包裹来解决性能损耗问题。例如外层给标签绑定指令 v-if 或者是内层标签绑定 v-if</p></blockquote><h2 id="单页面应用和多页面应用区别及优缺点"><a class="header-anchor" href="#单页面应用和多页面应用区别及优缺点" aria-hidden="true">#</a> 单页面应用和多页面应用区别及优缺点?</h2><ul><li>单页应用： <ul><li>优点： <ul><li>用户体验好，快，内容的改变不需要重新加载整个页面，基于这一点 SPA 对服务器压力较小</li><li>前后端分离</li><li>页面切换体验好</li></ul></li><li>缺点： <ul><li>不利于 SEO</li><li>导航不可用，需要自己实现导航</li><li>初次加载好事长</li><li>页面复杂度提高</li></ul></li></ul></li><li>多页应用 <ul><li>优点： <ul><li>对于 SEO 友好</li><li>容易扩展</li><li>更易的数据分析</li></ul></li><li>缺点： <ul><li>程序开发成本高</li><li>增加服务端压力，多页面会不停的加载</li><li>用户体验相对较差</li></ul></li></ul></li></ul><h2 id="v-model-该如何实现？"><a class="header-anchor" href="#v-model-该如何实现？" aria-hidden="true">#</a> v-model  该如何实现？</h2><blockquote><p>v-model 本质上是 v-on 和 v-bind 的语法糖。 v-model 在内部为不同元素抛出不同的事件，如：text 和 textarea 元素使用 value 属性和 input 事件；checkbox 和 radio 使用 checked 属性和 change 事件；select 字段将 value 作为 prop 并将 change 作为事件。</p></blockquote><ul><li>v-model 作用在普通表单上</li></ul><div class="language-javascript"><pre><code><span class="token operator">&lt;</span>input v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">&quot;myvalue&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>\n<span class="token comment">//  等同于</span>\n<span class="token operator">&lt;</span>input v<span class="token operator">-</span>bind<span class="token operator">:</span>value<span class="token operator">=</span><span class="token string">&quot;myvalue&quot;</span> v<span class="token operator">-</span>on<span class="token operator">:</span>input<span class="token operator">=</span><span class="token string">&quot;myvalue=$event.target.value&quot;</span><span class="token operator">&gt;</span>\n</code></pre></div><p>v-model 作用在组件上 父组件 v-model 语法糖本质上可以修改为 <code>&lt;child :value=&quot;message&quot; @input=&quot;function(e){message = e}&quot;&gt;&lt;/child&gt;</code>在组件的实现中，我们是可以通过 v-model 属性 来配置子组件接收的 prop 名称，以及派发的事件名称。例如：</p><div class="language-javascript"><pre><code><span class="token comment">// 父组件</span>\n<span class="token comment">//html</span>\n<span class="token operator">&lt;</span>mycom v<span class="token operator">-</span>model<span class="token operator">=</span><span class="token string">&quot;myvalue&quot;</span> <span class="token operator">/</span><span class="token operator">&gt;</span>\n<span class="token comment">//等同于</span>\n<span class="token operator">&lt;</span>mycom\n    <span class="token operator">:</span>value<span class="token operator">=</span><span class="token string">&quot;myvalue&quot;</span>\n    @input<span class="token operator">=</span><span class="token string">&quot;(e)=&gt;{myvalue = e}&quot;</span>\n<span class="token operator">/</span><span class="token operator">&gt;</span>\n\n<span class="token comment">//js</span>\n<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    el<span class="token operator">:</span> <span class="token string">&quot;#app&quot;</span><span class="token punctuation">,</span>\n    components<span class="token operator">:</span><span class="token punctuation">{</span>\n        mycom\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    data<span class="token operator">:</span> <span class="token punctuation">{</span>\n        myvalue<span class="token operator">:</span> <span class="token string">&quot;123&quot;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 子组件</span>\n<span class="token keyword">let</span> mycom <span class="token operator">=</span> <span class="token punctuation">{</span>\n    props<span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">&#39;value&#39;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n    template<span class="token operator">:</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">&lt;div&gt;&lt;input :value=&quot;value&quot;  @input=&quot;fn&quot; /&gt;&lt;/div&gt;</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>\n    methods<span class="token operator">:</span><span class="token punctuation">{</span>\n        <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n            <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">&#39;input&#39;</span><span class="token punctuation">,</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>value<span class="token punctuation">)</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n</code></pre></div><h2 id="vue2-中为什么检测不到数组的变化，如何解决"><a class="header-anchor" href="#vue2-中为什么检测不到数组的变化，如何解决" aria-hidden="true">#</a> vue2 中为什么检测不到数组的变化，如何解决?</h2><p>由于由 JavaScript 的限制，Vue 不能检测数组变动。解决方案是通过全局 Vue.set 或者用实例方法 vm.$set 来修改。同样也可以通过变异方法 splice 来修改数组触发数据响应式</p><h2 id="在-react-项目中，想要进行逻辑复用-有哪些方案？"><a class="header-anchor" href="#在-react-项目中，想要进行逻辑复用-有哪些方案？" aria-hidden="true">#</a> 在 React 项目中，想要进行逻辑复用,有哪些方案？</h2><h3 id="组件逻辑复用、组件视图复用"><a class="header-anchor" href="#组件逻辑复用、组件视图复用" aria-hidden="true">#</a> 组件逻辑复用、组件视图复用</h3><h4 id="逻辑复用：hoc（高阶组件）"><a class="header-anchor" href="#逻辑复用：hoc（高阶组件）" aria-hidden="true">#</a> 逻辑复用：HOC（高阶组件）</h4><blockquote><p>HOC（高阶组件）类似于高阶函数，在使用高阶组件时，传入一个组件，会返回一个组件。 举个我们使用频率比较多的例子 - withRouter</p></blockquote><div class="language-javascript"><pre><code><span class="token keyword">function</span> <span class="token function">Acmp</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> <span class="token punctuation">{</span> history<span class="token punctuation">,</span> localtion<span class="token punctuation">,</span> match <span class="token punctuation">}</span> <span class="token operator">=</span> props\n    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>view<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> Bcmp <span class="token operator">=</span> <span class="token function">withRouter</span><span class="token punctuation">(</span>Acmp<span class="token punctuation">)</span>\n</code></pre></div><p><code>Acmp</code>组件本身不具备路由相关信息；但是<code>Acmp</code>中想要使用路由相关的信息，这是就可以使用<code>withRouter()</code>使<code>Acmp</code>拥有路由信息</p><p><code>withRouter()</code>这个高阶组件的作用就是复用传递给视图组件路由信息的逻辑；调用<code>withRouter()</code>将<code>Acmp</code>组件传递进去，<code>withRouter()</code>返回一个<code>Bcmp</code>；调用<code>Bcmp</code>组件时，会调用<code>Acmp</code>组件，并将路由信息传递给<code>Acmp</code></p><p>原理如下：</p><div class="language-javascript"><pre><code><span class="token keyword">const</span> <span class="token function-variable function">withRouter</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">Cmp</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token operator">&lt;</span>Route component<span class="token operator">=</span><span class="token punctuation">{</span>Cmp<span class="token punctuation">}</span><span class="token operator">&gt;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h4 id="hooks"><a class="header-anchor" href="#hooks" aria-hidden="true">#</a> hooks</h4><blockquote><p><code>hooks</code>的出现，主要目的就是解决逻辑复用的问题，相比高阶组件，<code>hooks</code> 的使用更加灵活，更自由。以<code>Router</code>的<code>hooks</code>对比<code>withRouter</code>；使用<code>withRouter</code>时，会一次性将路由所有相关数据导入组件，而 <code>hooks</code> 我们按照需求汁倒入<code>location</code>和<code>history</code>等；另外一个组件中，用<code>redux</code>相关数据，有需要路由信息时，结果如下</p></blockquote><div class="language-javascript"><pre><code><span class="token keyword">function</span> <span class="token function">Acmp</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> <span class="token punctuation">{</span> history<span class="token punctuation">,</span> location<span class="token punctuation">,</span> match <span class="token punctuation">}</span> <span class="token operator">=</span> props\n    <span class="token keyword">return</span> <span class="token operator">&lt;</span>div<span class="token operator">&gt;</span>view<span class="token operator">&lt;</span><span class="token operator">/</span>div<span class="token operator">&gt;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> Bcmp <span class="token operator">=</span> <span class="token function">withRouter</span><span class="token punctuation">(</span>Acmp<span class="token punctuation">)</span>\n<span class="token keyword">const</span> Ccmp <span class="token operator">=</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token parameter">state</span> <span class="token operator">=&gt;</span> state<span class="token punctuation">)</span><span class="token punctuation">(</span>Bcmp<span class="token punctuation">)</span>\n</code></pre></div><p>复用一个逻辑就需要在外面包一层，使用起来极不方便；使用 <code>hooks</code> 就比这方便得多且灵活</p><h4 id="render-props"><a class="header-anchor" href="#render-props" aria-hidden="true">#</a> render props</h4><p>render props 同样是 react 中，复用逻辑的小技巧，并不是标准定义的 API。 简单来说，就是组件具有一个 <code>render</code> 属性，该属性接收的是一个函数，该组件中要渲染的视图是 <code>render</code> 属性的返回值。 举一个我们使用最多的常见，<code>Route</code> 组件的 <code>render</code> 属性。</p><div class="language-javascript"><pre><code><span class="token operator">&lt;</span>Route path<span class="token operator">=</span><span class="token string">&quot;/home&quot;</span> render<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token operator">&lt;</span>Home <span class="token operator">/</span><span class="token operator">&gt;</span><span class="token punctuation">}</span> <span class="token operator">/</span><span class="token operator">&gt;</span>\n</code></pre></div><p><code>Route</code> 组件中得这个 <code>render</code> 属性就是一个关于 render props 得实际应用；将组件内要渲染得视图放在 <code>render</code> 属性得返回值中，而组件本身是一个路由逻辑得公用。这样就做到了功能复用而视图自定义。</p><p>Route 简易原理如下：</p><div class="language-javascript"><pre><code><span class="token keyword">function</span> <span class="token function">Route</span><span class="token punctuation">(</span><span class="token parameter">props</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> <span class="token punctuation">{</span> path<span class="token punctuation">,</span> render <span class="token punctuation">}</span> <span class="token operator">=</span> props\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">matchPath</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token punctuation">(</span>\n            <span class="token operator">&lt;</span>RouterContext<span class="token punctuation">.</span>Consumer<span class="token operator">&gt;</span>\n                <span class="token punctuation">{</span><span class="token parameter">context</span> <span class="token operator">=&gt;</span> <span class="token function">render</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">}</span>\n            <span class="token operator">&lt;</span><span class="token operator">/</span>ROuterContext<span class="token punctuation">.</span>Consumer<span class="token operator">&gt;</span>\n        <span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> <span class="token keyword">null</span>\n<span class="token punctuation">}</span>\n</code></pre></div><blockquote><p>高阶组件或 hook，通常用在单一的逻辑复用，比如实时获取当前滚动条位置，或定义 <code>state</code>，副作用处理等，都是单一的逻辑。 而 render props 通常是一个完整的功能复用，只是该功能中视图或部分视图需要由使用者定义，比如，弹窗功能，路由功能 等，项目中使用到这些功能的地方有很多，但是使用时，视图可能有差异</p></blockquote><h2 id="在-react-中，针对类组件-和-函数组件，分别怎么去进行性能优化？"><a class="header-anchor" href="#在-react-中，针对类组件-和-函数组件，分别怎么去进行性能优化？" aria-hidden="true">#</a> 在 React 中，针对类组件 和 函数组件，分别怎么去进行性能优化？</h2><p>React 中，如果组件更新了，会携带它的子孙级组件一起进行更新，虽然组件更新时，会有 diff 约束 DOM 更新。 但组件更新时的 diff，也会消耗很多性能。 如何避免项目中不必要的组件更新就是我们必须要面对的问题。 如果是类组件我们可以使用 <code>shouldComponentUpdate</code> 或者<code>PureComponent</code> , 函数组件则可以使用 hooks <code>useMemo()</code></p><div class="tip custom-block"><p class="custom-block-title">注意</p><p>不管你使用的是哪种优化手段，<code>state</code> 一定是一个不可变值，否则拿不到组件更新前的数据， 也就没有办法进行对比，优化也就无从谈起。<br> 官网手册：<a href="https://reactjs.org/docs/react-api.html#reactmemo" target="_blank" rel="noopener noreferrer">React.memo</a>、<a href="https://reactjs.org/docs/react-api.html#reactpurecomponent" target="_blank" rel="noopener noreferrer">React.PureComponent</a></p></div><h2 id="vue3-中-teleport-的作用是什么"><a class="header-anchor" href="#vue3-中-teleport-的作用是什么" aria-hidden="true">#</a> Vue3 中 Teleport 的作用是什么</h2><blockquote><p>他的作用就是将一个嵌套在组件内部的某些内容可以渲染到当前组件外部。 假设我们有一个 modal 组件，该组件分为触发 modal 打开的 button 以及模态框本体</p></blockquote><div class="language-HTML"><pre><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token style-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span><span class="token style language-css"><span class="token property">position</span><span class="token punctuation">:</span> relative<span class="token punctuation">;</span></span><span class="token punctuation">&quot;</span></span></span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>modalOpen = true<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>    Open full screen modal!  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>telepot</span> <span class="token attr-name">to</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>body<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">v-if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>modalOpen<span class="token punctuation">&quot;</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>modal<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>\n            I&#39;m a modal!\n            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">@click</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>modalOpen = false<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>Close<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>telepot</span><span class="token punctuation">&gt;</span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>\n</code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p><h3 id="teleport-可以包含-vue-组件使用么？"><a class="header-anchor" href="#teleport-可以包含-vue-组件使用么？" aria-hidden="true">#</a> teleport 可以包含 vue 组件使用么？</h3><p>可以，当 teleport 包含的是 vue 组件时，只是将该组件渲染到对应的标签当中，他的 props 等依然是从该组件的父组件进行注入。</p><h3 id="可以使用多个-teleport-指向同一标签么？"><a class="header-anchor" href="#可以使用多个-teleport-指向同一标签么？" aria-hidden="true">#</a> 可以使用多个 teleport 指向同一标签么？</h3><p>可以的，就比如有一个复用的 modal 组件，他在多个地方被使用时会被指向相同标签比如 body。这时将会按照顺序进行追加，后挂载的元素会在较早挂载元素之后的位置。</p></div><h2 id="说一下-vue3-的-composition-api"><a class="header-anchor" href="#说一下-vue3-的-composition-api" aria-hidden="true">#</a> 说一下 vue3 的 composition api?</h2><blockquote><p>composition api 意为组合式 api，其主要是代码组织结构上的变动。vue2 版本的 options api，通过一个配置集合将代码划分为多个部分，使得代码组织结构比较清晰，比如父组件直接传入的数据存放于<code>props</code>，方法存放于<code>methods</code>等，但是其代码逻辑复用方面一直表现得不是很友好。composition api 就是用于解决该问题，在 vue3 当中新增加了一个生命周期函数为<code>setup</code>。<code>setup</code>将在创建组件之前被执行，一旦<code>props</code>被解析时，<code>setup</code>将服务于 composition api 充当入口点。从使用角度来讲 composition api 主要有以下几点与 options api 不同响应式数据声明改变，通过<code>ref/reactive</code>两个方法均可以声明响应式数据，但是两者使用方式略有不同。<code>ref</code>所声明的响应式变量将会返回一个包含有 value 属性的对象，value 的值就是该响应式变量所对应的值。所以在不论在获取还是改变 ref 声明的响应式变量时都需要通过.value 进行操作。<code>reactive</code>返回的则是通过<code>Proxy</code>处理后的对象。使用生命周期函数时，变为从 vue 中引入对应生命周期函数例如<code>onMounted</code>，生命周期函数接受一个函数作为参数，该函数将会在对应生命周期阶段被执行。<code>watch</code>使用方式改变，<code>watch</code>作为函数接受至少两个参数，第一个参数为被<code>watch</code>的响应式数据，第二个参数为回调函数。当<code>watch</code>接受的响应式数据不同会有不同的使用方式，当<code>watch</code>的数据为通过<code>ref</code>声明的响应式变量时，<code>watch</code>直接接受<code>ref</code>响应式变量如<code>watch(refValue)</code>。当<code>watch</code>数据为通过<code>reactive</code>声明时，需要传入一个函数，该函数返回 reactive 变量如<code>watch(() =&gt; reactiveValue.value)</code>。同时新增 watchEffect，他会收集内部依赖，当内部依赖发生改变时就会被执行。<code>props</code>现在作为<code>setup</code>的第一个参数进行接收，使用<code>props</code>时可以通过 vue 暴露的<code>toRefs</code>方法将<code>props</code>上的属性转为独立的<code>ref</code>响应式变量，从而进行使用。在<code>setup</code>当中代码将可以根据功能进行组织并提取，这极大程度的解决了以往代码可读性较低以及逻辑服用难的缺点。</p><h3 id="composition-api-是强制使用的么？我还可以在-vue3-中使用-options-api-的方式进行开发么？"><a class="header-anchor" href="#composition-api-是强制使用的么？我还可以在-vue3-中使用-options-api-的方式进行开发么？" aria-hidden="true">#</a> composition api 是强制使用的么？我还可以在 vue3 中使用 options api 的方式进行开发么？</h3><p>composition api 并不被强制使用，他只是在大型项目中对于代码复用以及逻辑提取上有很大的有点，并且他极大的提高了代码可读性。vue3 是向下兼容的，在 vue3 当中依然可以通过 options api 进行开发。同时尤大本人曾在 Vue Mastery 上表示过，对于新手来讲，options api 的学习可能对于上手 vue 来说更加快速。</p><h3 id="我还可以在-setup-中通过-this-来使用实例上的属性么？"><a class="header-anchor" href="#我还可以在-setup-中通过-this-来使用实例上的属性么？" aria-hidden="true">#</a> 我还可以在 setup 中通过 this 来使用实例上的属性么？</h3><p>不可以，因为<code>setup</code>执行是在组件创建之前，这时还并没有组件实例，所以在 setup 中并没有 this，如果希望使用一些实例上的方法，可以通过<code>getCurrentInstance</code>方法先获取实例在进行操作。</p></blockquote><h2 id="vue3-中-v-model-的变化"><a class="header-anchor" href="#vue3-中-v-model-的变化" aria-hidden="true">#</a> vue3 中 v-model 的变化?</h2><blockquote><p>vue3 取消了.sync 修饰符的使用，直接使用 v-model 进行替换即可。对于自定义组件使用 v-model 时，prop 与事件的默认名称变更，从 vue2 版本的 value/@input 变更为 modelValue/@update:modelValue。修改 model 的名称从原来的 model 选项进行修改，变更为传递参数给 model，写法为 v-model:argument。使用 v-model 参数后会改变 prop 和事件名为 argument/@update:argument。现在一个组件可以同时使用多个 v-model 进行绑定。并且在 vue3 中 v-model 支持自定义修饰符，他将会通过 props 中的 modelModifiers 属性接收。</p></blockquote><h3 id="是否还可以使用-vue2-版本的方式配置-model-名称？"><a class="header-anchor" href="#是否还可以使用-vue2-版本的方式配置-model-名称？" aria-hidden="true">#</a> 是否还可以使用 vue2 版本的方式配置 model 名称？</h3><blockquote><p>不可以，v-model 参数是一个不向下兼容的改动，在 vue3 中修改 model 的名称就是通过 v-model 参数进行修改。</p></blockquote><h3 id="在同一个组件上绑定多个-v-model-时需不需要单独进行配置？"><a class="header-anchor" href="#在同一个组件上绑定多个-v-model-时需不需要单独进行配置？" aria-hidden="true">#</a> 在同一个组件上绑定多个 v-model 时需不需要单独进行配置？</h3><blockquote><p>绑定多个 v-model 的时候只要传参对 model 名称进行变更，每个 v-model 将会同步到不同的 prop 属性当中，所以并不需要在组件中添加额外的选项进行配置。</p></blockquote><h2 id="说一下-vue3-与-vue2-的对比？"><a class="header-anchor" href="#说一下-vue3-与-vue2-的对比？" aria-hidden="true">#</a> 说一下 Vue3 与 Vue2 的对比？</h2><p>首先从性能层面讲，vue3 不论是渲染速度或是打包速度均快于 vue2，这里有以下几个原因数据劫持方式改变，原有通过 Object.defineProperty 进行的数据劫持改变为 Proxy 进行数据代理。由于 Proxy 可以动态判断该数据是否为深层嵌套数据，而 Object.defineProperty 为遍历全部深层嵌套数据，导致两者仅在数据劫持上就产生了极大的时间差距。vue3 打包策略，vue3 支持了 tree-shaking，即排除任何未实际使用的代码，打包体积极大缩小。同时由于打包后体积缩小文件数量减少，页面加载文件所需时间也极大缩短。diff 优化，vue3 中会对静态节点进行提升，所有静态节点(及不包含任何响应式数据及事件等)在进行比对时不会被遍历。这促使 vue3 在进行节点比对时所需的比对时间大幅减少。性能之后还有生命周期的改变，vue2 中的 beforeCreate 与 created 被 setup 一个生命周期所替代，同时 beforeDestroy 与 destroyed 分别改名为 beforeUnmount 与 unmounted。同时 vue3 当中的响应式数据声明也有所改变，但这主要体现与在 setup 中进行响应式数据的声明。vue3 当中暴露了两个方法，分别是 reactive 与 ref 方法。他们均是用来声明响应式数据，只是对于不同情况有各自的有点。由上面一点可以引出 vue3 当中发生的最大改变 - composition api。vue3 的代码组织有以前的 options api 切换到了 composition api，这使得我们在处理大型项目时不会再像以前一样，一个功能的代码将被分割到 data、computed、method 等等当中，我们可以将相同功能代码提出进行封装，这极大提高了代码可读性。除此以外 vue3 中双向绑定也进行了修改。vue3 中取消了 v-bind 的.sync 修饰符，因为这更符合 v-model 的逻辑。v-model 主要有以下两点不同：一个组件可以同时包含多个 v-model，model 名称的更改由之前的 model 选项变更为传递一个参数给 model，传参方式为 v-model:argument 当 v-model 用于自定义组件时，prop 与事件的默认名称由以前的 value/@input 变更为 modelValue/@update:modelValue。如果使用了 v-model 参数改变了 model 名字，比如 v-model:title，则对应 prop 与事件名称为 title/@update:title。最后 vue3 对 ts 的支持程度也是 vue2 所不能达到的，例如 vue3 当中提供了一个 defineComponent，他能为 props 提供完整的类型推断。</p><h2 id="在组件的通信中-eventbus-非常经典，你能手写实现下-eventbus-么？"><a class="header-anchor" href="#在组件的通信中-eventbus-非常经典，你能手写实现下-eventbus-么？" aria-hidden="true">#</a> 在组件的通信中 EventBus 非常经典，你能手写实现下 EventBus 么？</h2><div class="language-javascript"><pre><code><span class="token keyword">class</span> <span class="token class-name">EventBusClass</span><span class="token punctuation">{</span>  \n    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    \n        <span class="token keyword">this</span><span class="token punctuation">.</span>msgList <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>  \n\n    <span class="token function">on</span><span class="token punctuation">(</span><span class="token parameter">msgName<span class="token punctuation">,</span>fn</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    \n        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>msgList<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>msgName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      \n            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span><span class="token punctuation">.</span>msgList<span class="token punctuation">[</span>msgName<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        \n                <span class="token keyword">this</span><span class="token punctuation">.</span>msgList<span class="token punctuation">[</span>msgName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>msgList<span class="token punctuation">[</span>msgName<span class="token punctuation">]</span><span class="token punctuation">,</span>fn<span class="token punctuation">]</span>    \n            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>        \n                <span class="token keyword">this</span><span class="token punctuation">.</span>msgList<span class="token punctuation">[</span>msgName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>msgList<span class="token punctuation">[</span>msgName<span class="token punctuation">]</span><span class="token punctuation">,</span> fn<span class="token punctuation">]</span>    \n            <span class="token punctuation">}</span>  \n        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>      \n            <span class="token keyword">this</span><span class="token punctuation">.</span>msgList<span class="token punctuation">[</span>msgName<span class="token punctuation">]</span> <span class="token operator">=</span> fn<span class="token punctuation">;</span>  \n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>  \n\n        <span class="token function">one</span><span class="token punctuation">(</span><span class="token parameter">msgName<span class="token punctuation">,</span>fn</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    \n            <span class="token keyword">this</span><span class="token punctuation">.</span>msgList<span class="token punctuation">[</span>msgName<span class="token punctuation">]</span> <span class="token operator">=</span> fn<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>  \n\n        <span class="token function">emit</span><span class="token punctuation">(</span><span class="token parameter">msgName<span class="token punctuation">,</span>msg</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    \n            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>msgList<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>msgName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      \n                <span class="token keyword">return</span>  \n            <span class="token punctuation">}</span>​    \n\n            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> <span class="token keyword">this</span><span class="token punctuation">.</span>msgList<span class="token punctuation">[</span>msgName<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">&#39;function&#39;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      \n                <span class="token keyword">this</span><span class="token punctuation">.</span>msgList<span class="token punctuation">[</span>msgName<span class="token punctuation">]</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>  \n            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>      \n                <span class="token keyword">this</span><span class="token punctuation">.</span>msgList<span class="token punctuation">[</span>msgName<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>        <span class="token function">fn</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span>  \n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>  \n\n        <span class="token function">off</span><span class="token punctuation">(</span><span class="token parameter">msgName</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    \n            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>msgList<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>msgName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      \n                <span class="token keyword">return</span><span class="token punctuation">;</span>  \n            <span class="token punctuation">}</span>    \n\n            <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">.</span>msgList<span class="token punctuation">[</span>msgName<span class="token punctuation">]</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>​\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> eventBus <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">EventBusClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nwindow<span class="token punctuation">.</span>EventBus <span class="token operator">=</span> eventBus<span class="token punctuation">;</span>\n\n</code></pre></div><h2 id="请介绍一下装饰者模式，并实现？"><a class="header-anchor" href="#请介绍一下装饰者模式，并实现？" aria-hidden="true">#</a> 请介绍一下装饰者模式，并实现？</h2><div class="language-javascript"><pre><code><span class="token keyword">class</span> <span class="token class-name">luban</span> <span class="token punctuation">{</span>  \n    <span class="token function">fire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    \n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;这里是基础伤害&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>​\n\n<span class="token keyword">class</span> <span class="token class-name">firstSkill</span><span class="token punctuation">{</span>  \n    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">luban</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    \n        <span class="token keyword">this</span><span class="token punctuation">.</span>luban <span class="token operator">=</span> luban<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>  \n\n    <span class="token function">fire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    \n        <span class="token keyword">this</span><span class="token punctuation">.</span>luban<span class="token punctuation">.</span><span class="token function">fire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    \n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;发射手雷&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n​<span class="token keyword">var</span> luban1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">luban</span><span class="token punctuation">;</span>\nluban1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">firstSkill</span><span class="token punctuation">(</span>luban1<span class="token punctuation">)</span><span class="token punctuation">;</span>\nluban1<span class="token punctuation">.</span><span class="token function">fire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div><h2 id="了解-js-中设计模式吗？动手实现一下单例模式？"><a class="header-anchor" href="#了解-js-中设计模式吗？动手实现一下单例模式？" aria-hidden="true">#</a> 了解 js 中设计模式吗？动手实现一下单例模式？</h2><div class="language-javascript"><pre><code><span class="token keyword">let</span> CreateSingle <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    \n    <span class="token keyword">let</span> instance<span class="token punctuation">;</span>    \n    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        \n        <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token punctuation">)</span><span class="token punctuation">{</span>            \n            <span class="token keyword">return</span> instance<span class="token punctuation">;</span>        \n        <span class="token punctuation">}</span>        \n        <span class="token keyword">return</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Single</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    \n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>​\n\n<span class="token keyword">let</span> <span class="token function-variable function">Single</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    \n    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>​\n\n<span class="token class-name">Single</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">getName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    \n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>​\n<span class="token keyword">let</span> lili <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CreateSingle</span><span class="token punctuation">(</span><span class="token string">&#39;lili&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">let</span> wuyou <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CreateSingle</span><span class="token punctuation">(</span><span class="token string">&#39;wuyou&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>​\nwuyou<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre></div><h2 id="虚拟-dom-有什么作用，如何构建虚拟-dom？"><a class="header-anchor" href="#虚拟-dom-有什么作用，如何构建虚拟-dom？" aria-hidden="true">#</a> 虚拟  DOM  有什么作用，如何构建虚拟 DOM？</h2><div class="language-javascript"><pre><code><span class="token keyword">class</span> <span class="token class-name">Vdom</span> <span class="token punctuation">{</span>\n    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">option</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>tagName <span class="token operator">=</span> option<span class="token punctuation">.</span>tagName\n        <span class="token keyword">this</span><span class="token punctuation">.</span>props <span class="token operator">=</span> option<span class="token punctuation">.</span>props <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>children <span class="token operator">=</span> option<span class="token punctuation">.</span>children <span class="token operator">||</span> <span class="token string">&#39;&#39;</span>\n    <span class="token punctuation">}</span>\n    <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">let</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>tagName<span class="token punctuation">)</span>\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> propsKay <span class="token keyword">in</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            el<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span>propsKay<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>props<span class="token punctuation">[</span>propsKay<span class="token punctuation">]</span><span class="token punctuation">)</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">this</span><span class="token punctuation">.</span>children<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">item</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n                el<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>item<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n            <span class="token punctuation">}</span><span class="token punctuation">)</span>\n        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n            el<span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>children\n        <span class="token punctuation">}</span>\n        <span class="token keyword">return</span> el\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h2 id="你对浏览器的理解？"><a class="header-anchor" href="#你对浏览器的理解？" aria-hidden="true">#</a> 你对浏览器的理解？</h2><blockquote><ul><li>浏览器的主要功能是将用户选择的 Web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是 HTML，也包括 PDF、image 及其他格式。用户用 URI（Uniform Resource Identifier 统一资源标识符）来指定所请求资源的位置。</li><li>HTML 和 CSS 规范中规定了浏览器解释 HTML 文档的方式，由 W3C 组织对这些规范进行维护，W3C 是负责制定 Web 标准的组织。</li><li>但是浏览器厂商纷纷开发自己的扩展，对规范的遵循并不完善，这为 Web 开发者带来了严重的兼容性问题。</li><li>简单来说浏览器可以分为两部分，shell（外壳） 和 内核。其中 shell 的种类相对比较多，内核则比较少。</li><li>shell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等。它是调用内核来实现各种功能的。</li><li>内核才是浏览器的核心。内核是基于标记语言显示内容的程序或模块。也有一些浏览器并不区分外壳和内核。自从 Mozilla 将 Gecko 独立出来后，才有了外壳和内核的明确划分。</li></ul></blockquote><h2 id="介绍一下你对浏览器内核的理解？"><a class="header-anchor" href="#介绍一下你对浏览器内核的理解？" aria-hidden="true">#</a> 介绍一下你对浏览器内核的理解？</h2><blockquote><ul><li>浏览器内核主要分成两部分：渲染引擎和 JS 引擎。</li><li>渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 HTML、XML 文档及图片，它也可以借助插件（一种浏览器扩展）显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。</li><li>JS 引擎：解析和执行 JavaScript 来实现网页的动态效果。</li><li>最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</li></ul></blockquote><h2 id="常见的浏览器内核比较"><a class="header-anchor" href="#常见的浏览器内核比较" aria-hidden="true">#</a> 常见的浏览器内核比较</h2><blockquote><ul><li>Trident：这种浏览器内核是 IE 浏览器用的内核，因为在早期 IE 占有大量的市场份额，所以这种内核比较流行，以前有很多网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。但是由于 IE 的高市场占有率，微软也很长时间没有更新 Trident 内核，就导致了 Trident 内核和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等安全问题没有得到解决，加上一些专家学者公开自己认为 IE 浏览器不安全的观点，使很多用户开始转向其他浏览器。</li><li>Gecko：这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。</li><li>Presto：Opera 曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快 3 倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。</li><li>Webkit：Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。</li><li>Blink：谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实 Blink 引擎就是 Webkit 的一个分支，就像 webkit 是 KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，Opera 弃用了自己的 Presto 内核，加入 Google 阵营，跟随谷歌一起研发 Blink。</li></ul></blockquote><p>参考</p><ul><li><a href="http://www.cnblogs.com/fullhouse/archive/2011/12/19/2293455.html" target="_blank" rel="noopener noreferrer">《浏览器内核的解析和对比》</a></li><li><a href="https://blog.csdn.net/Summer_15/article/details/71249203" target="_blank" rel="noopener noreferrer">《五大主流浏览器内核的源起以及国内各大浏览器内核总结》</a></li></ul><h2 id="extend-能做什么"><a class="header-anchor" href="#extend-能做什么" aria-hidden="true">#</a> extend 能做什么</h2><p>这个 API 很少用到，作用是扩展组件生成一个构造器，通常会与 <code>$mount</code> 一起使用。</p><div class="language-javascript"><pre><code><span class="token comment">// 创建组件构造器</span>\n<span class="token keyword">let</span> Component <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    template<span class="token operator">:</span> <span class="token string">&#39;&lt;div&gt;test&lt;/div&gt;&#39;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token comment">// 挂载到 #app 上</span>\n<span class="token keyword">new</span> <span class="token class-name">Component</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">&#39;#app&#39;</span><span class="token punctuation">)</span>\n<span class="token comment">// 除了上面的方式，还可以用来扩展已有的组件</span>\n<span class="token keyword">let</span> SuperComponent <span class="token operator">=</span> Vue<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span>Component<span class="token punctuation">)</span>\n<span class="token keyword">new</span> <span class="token class-name">SuperComponent</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    <span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token keyword">new</span> <span class="token class-name">SuperComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span><span class="token string">&#39;#app&#39;</span><span class="token punctuation">)</span>\n</code></pre></div><h2 id="mixin-和-mixins-区别"><a class="header-anchor" href="#mixin-和-mixins-区别" aria-hidden="true">#</a> mixin 和 mixins 区别</h2><blockquote><p><code>mixin</code> 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。</p></blockquote><p>虽然文档不建议我们在应用中直接使用 <code>mixin</code>，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的 <code>ajax</code> 或者一些工具函数等等。</p><div class="language-javascript"><pre><code>Vue<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    <span class="token function">beforeCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// ...逻辑</span>\n        <span class="token comment">// 这种方式会影响到每个组件的 beforeCreate 钩子函数</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><p><code>mixins</code> 应该是我们最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 <code>mixins</code> 混入代码，比如上拉下拉加载数据这种逻辑等等。</p><p>另外需要注意的是 <code>mixins</code> 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并，具体可以阅读文档。</p><h2 id="响应式原理"><a class="header-anchor" href="#响应式原理" aria-hidden="true">#</a> 响应式原理</h2><p>Vue 内部使用了 <code>Object.defineProperty()</code> 来实现数据响应式，通过这个函数可以监听到 <code>set</code> 和 <code>get</code> 的事件。</p><div class="language-javascript"><pre><code><span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&#39;yck&#39;</span> <span class="token punctuation">}</span>\n<span class="token function">observe</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>\n<span class="token keyword">let</span> name <span class="token operator">=</span> data<span class="token punctuation">.</span>name <span class="token comment">// -&gt; get value</span>\ndata<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&#39;yyy&#39;</span> <span class="token comment">// -&gt; change value</span>\n\n<span class="token keyword">function</span> <span class="token function">observe</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 判断类型</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>obj <span class="token operator">||</span> <span class="token keyword">typeof</span> obj <span class="token operator">!==</span> <span class="token string">&#39;object&#39;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span>\n    <span class="token punctuation">}</span>\n    Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">key</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n        <span class="token function">defineReactive</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 递归子属性</span>\n    <span class="token function">observe</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>\n    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 可枚举</span>\n        enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n        <span class="token comment">// 可配置</span>\n        configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n        <span class="token comment">// 自定义函数</span>\n        <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">reactiveGetter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;get value&#39;</span><span class="token punctuation">)</span>\n            <span class="token keyword">return</span> val\n        <span class="token punctuation">}</span><span class="token punctuation">,</span>\n        <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">reactiveSetter</span><span class="token punctuation">(</span><span class="token parameter">newVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;change value&#39;</span><span class="token punctuation">)</span>\n            val <span class="token operator">=</span> newVal\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>以上代码简单的实现了如何监听数据的 <code>set</code> 和 <code>get</code> 的事件，但是仅仅如此是不够的，因为自定义的函数一开始是不会执行的。只有先执行了依赖收集，才能在属性更新的时候派发更新，所以接下来我们需要先触发依赖收集。</p><div class="language-html"><pre><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>{{name}}<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>\n</code></pre></div><p>在解析如上模板代码时，遇到双大括号就会进行依赖收集。</p><p>接下来我们先来实现一个 <code>Dep</code> 类，用于解耦属性的依赖收集和派发更新操作。</p><div class="language-javascript"><pre><code><span class="token comment">// 通过 Dep 解耦属性的依赖和更新操作</span>\n<span class="token keyword">class</span> <span class="token class-name">Dep</span> <span class="token punctuation">{</span>\n    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>subs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>\n    <span class="token punctuation">}</span>\n    <span class="token comment">// 添加依赖</span>\n    <span class="token function">addSub</span><span class="token punctuation">(</span><span class="token parameter">sub</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n    <span class="token comment">// 更新</span>\n    <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">sub</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n            sub<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n        <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// 全局属性，通过该属性配置 Watcher</span>\nDep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span>\n</code></pre></div><p>以上的代码实现很简单，当需要依赖收集的时候调用 <code>addSub</code>，当需要派发更新的时候调用 <code>notify</code>。</p><p>接下来我们先来简单的了解下 Vue 组件挂载时添加响应式的过程。在组件挂载时，会先对所有需要的属性调用 <code>Object.defineProperty()</code>，然后实例化 <code>Watcher</code>，传入组件更新的回调。在实例化过程中，会对模板中的属性进行求值，触发依赖收集。</p><p>因为这一小节主要目的是学习响应式原理的细节，所以接下来的代码会简略的表达触发依赖收集时的操作。</p><div class="language-javascript"><pre><code><span class="token keyword">class</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>\n    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> cb</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 将 Dep.target 指向自己</span>\n        <span class="token comment">// 然后触发属性的 getter 添加监听</span>\n        <span class="token comment">// 最后将 Dep.target 置空</span>\n        Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>cb <span class="token operator">=</span> cb\n        <span class="token keyword">this</span><span class="token punctuation">.</span>obj <span class="token operator">=</span> obj\n        <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key\n        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span>\n        Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span>\n    <span class="token punctuation">}</span>\n    <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 获得新值</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">[</span><span class="token keyword">this</span><span class="token punctuation">.</span>key<span class="token punctuation">]</span>\n        <span class="token comment">// 调用 update 方法更新 Dom</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">cb</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>以上就是 <code>Watcher</code> 的简单实现，在执行构造函数的时候将 <code>Dep.target</code> 指向自身，从而使得收集到了对应的 Watcher，在派发更新的时候取出对应的 <code>Watcher</code> 然后执行 <code>update</code> 函数。</p><p>接下来，需要对 <code>defineReactive</code> 函数进行改造，在自定义函数中添加依赖收集和派发更新相关的代码。</p><div class="language-javascript"><pre><code><span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 递归子属性</span>\n    <span class="token function">observe</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>\n    <span class="token keyword">let</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n        enumerable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n        configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n        <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">reactiveGetter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;get value&#39;</span><span class="token punctuation">)</span>\n            <span class="token comment">// 将 Watcher 添加到订阅</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                dp<span class="token punctuation">.</span><span class="token function">addSub</span><span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span>\n            <span class="token punctuation">}</span>\n            <span class="token keyword">return</span> val\n        <span class="token punctuation">}</span><span class="token punctuation">,</span>\n        <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token function">reactiveSetter</span><span class="token punctuation">(</span><span class="token parameter">newVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;change value&#39;</span><span class="token punctuation">)</span>\n            val <span class="token operator">=</span> newVal\n            <span class="token comment">// 执行 watcher 的 update 方法</span>\n            dp<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>以上所有代码实现了一个简易的数据响应式，核心思路就是手动触发一次属性的 <code>getter</code> 来实现依赖收集。</p><p>现在我们就来测试下代码的效果，只需要把所有的代码复制到浏览器中执行，就会发现页面的内容全部被替换了。</p><div class="language-javascript"><pre><code><span class="token keyword">var</span> data <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">&#39;yck&#39;</span> <span class="token punctuation">}</span>\n<span class="token function">observe</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>\n<span class="token keyword">function</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">&#39;div&#39;</span><span class="token punctuation">)</span><span class="token punctuation">.</span>innerText <span class="token operator">=</span> value\n<span class="token punctuation">}</span>\n<span class="token comment">// 模拟解析到 `{{name}}` 触发的操作</span>\n<span class="token keyword">new</span> <span class="token class-name">Watcher</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token string">&#39;name&#39;</span><span class="token punctuation">,</span> update<span class="token punctuation">)</span>\n<span class="token comment">// update Dom innerText</span>\ndata<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">&#39;yyy&#39;</span>\n</code></pre></div><p><code>Object.defineProperty</code> 的缺陷 以上已经分析完了 Vue 的响应式原理，接下来说一点 <code>Object.defineProperty</code> 中的缺陷。</p><p>如果通过下标方式修改数组数据或者给对象新增属性并不会触发组件的重新渲染，因为 <code>Object.defineProperty</code> 不能拦截到这些操作，更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。</p><p>对于第一个问题，Vue 提供了一个 API 解决</p><div class="language-javascript"><pre><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token operator">:</span> Array<span class="token operator">&lt;</span>any<span class="token operator">&gt;</span> <span class="token operator">|</span> Object<span class="token punctuation">,</span> key<span class="token operator">:</span> any<span class="token punctuation">,</span> val<span class="token operator">:</span> any</span><span class="token punctuation">)</span><span class="token operator">:</span> any <span class="token punctuation">{</span>\n    <span class="token comment">// 判断是否为数组且下标是否有效</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">isValidArrayIndex</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 调用 splice 函数触发派发更新</span>\n        <span class="token comment">// 该函数已被重写</span>\n        target<span class="token punctuation">.</span>length <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>length<span class="token punctuation">,</span> key<span class="token punctuation">)</span>\n        target<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span>\n        <span class="token keyword">return</span> val\n    <span class="token punctuation">}</span>\n    <span class="token comment">// 判断 key 是否已经存在</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token keyword">in</span> target <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val\n        <span class="token keyword">return</span> val\n    <span class="token punctuation">}</span>\n    <span class="token keyword">const</span> ob <span class="token operator">=</span> <span class="token punctuation">(</span>target<span class="token operator">:</span> any<span class="token punctuation">)</span><span class="token punctuation">.</span>__ob__\n    <span class="token comment">// 如果对象不是响应式对象，就赋值返回</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>ob<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        target<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> val\n        <span class="token keyword">return</span> val\n    <span class="token punctuation">}</span>\n    <span class="token comment">// 进行双向绑定</span>\n    <span class="token function">defineReactive</span><span class="token punctuation">(</span>ob<span class="token punctuation">.</span>value<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">)</span>\n    <span class="token comment">// 手动派发更新</span>\n    ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token keyword">return</span> val\n<span class="token punctuation">}</span>\n</code></pre></div><p>对于数组而言，Vue 内部重写了以下函数实现派发更新</p><div class="language-javascript"><pre><code><span class="token comment">// 获得数组原型</span>\n<span class="token keyword">const</span> arrayProto <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype\n<span class="token keyword">export</span> <span class="token keyword">const</span> arrayMethods <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>arrayProto<span class="token punctuation">)</span>\n<span class="token comment">// 重写以下函数</span>\n<span class="token keyword">const</span> methodsToPatch <span class="token operator">=</span> <span class="token punctuation">[</span>\n    <span class="token string">&#39;push&#39;</span><span class="token punctuation">,</span>\n    <span class="token string">&#39;pop&#39;</span><span class="token punctuation">,</span>\n    <span class="token string">&#39;shift&#39;</span><span class="token punctuation">,</span>\n    <span class="token string">&#39;unshift&#39;</span><span class="token punctuation">,</span>\n    <span class="token string">&#39;splice&#39;</span><span class="token punctuation">,</span>\n    <span class="token string">&#39;sort&#39;</span><span class="token punctuation">,</span>\n    <span class="token string">&#39;reverse&#39;</span>\n<span class="token punctuation">]</span>\nmethodsToPatch<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">method</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 缓存原生函数</span>\n    <span class="token keyword">const</span> original <span class="token operator">=</span> arrayProto<span class="token punctuation">[</span>method<span class="token punctuation">]</span>\n    <span class="token comment">// 重写函数</span>\n    <span class="token function">def</span><span class="token punctuation">(</span>arrayMethods<span class="token punctuation">,</span> method<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token function">mutator</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 先调用原生函数获得结果</span>\n        <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">original</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span>\n        <span class="token keyword">const</span> ob <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>__ob__\n        <span class="token keyword">let</span> inserted\n        <span class="token comment">// 调用以下几个函数时，监听新数据</span>\n        <span class="token keyword">switch</span> <span class="token punctuation">(</span>method<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">case</span> <span class="token string">&#39;push&#39;</span><span class="token operator">:</span>\n            <span class="token keyword">case</span> <span class="token string">&#39;unshift&#39;</span><span class="token operator">:</span>\n                inserted <span class="token operator">=</span> args\n                <span class="token keyword">break</span>\n            <span class="token keyword">case</span> <span class="token string">&#39;splice&#39;</span><span class="token operator">:</span>\n                inserted <span class="token operator">=</span> args<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>\n                <span class="token keyword">break</span>\n        <span class="token punctuation">}</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>inserted<span class="token punctuation">)</span> ob<span class="token punctuation">.</span><span class="token function">observeArray</span><span class="token punctuation">(</span>inserted<span class="token punctuation">)</span>\n        <span class="token comment">// 手动派发更新</span>\n        ob<span class="token punctuation">.</span>dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n        <span class="token keyword">return</span> result\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre></div><h2 id="二、vue3-中的数据响应式是怎么实现的？"><a class="header-anchor" href="#二、vue3-中的数据响应式是怎么实现的？" aria-hidden="true">#</a> <strong>二、Vue3 中的数据响应式是怎么实现的？</strong></h2><p><strong>答案:</strong></p><div class="language-js"><pre><code><span class="token function">observe</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> _this <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>_data <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n        <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">let</span> event <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CustomEvent</span><span class="token punctuation">(</span>prop<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n                detail<span class="token operator">:</span> newValue\n            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n            _this<span class="token punctuation">.</span><span class="token function">dispatchEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><h2 id="请简述-vue-中-template-的实现思路？"><a class="header-anchor" href="#请简述-vue-中-template-的实现思路？" aria-hidden="true">#</a> 请简述 Vue 中 Template 的实现思路？</h2><ul><li>第一步是将 模板字符串 转换成 element ASTs（解析器）(abstract syntax tree,抽象语法树）</li><li>第二步是对 AST 进行静态节点标记，主要用来做虚拟 DOM 的渲染优化（优化器）</li><li>第三步是 使用 element ASTs 生成 render 函数代码字符串（代码生成器）</li></ul><h2 id="如何把真实-dom-转变为虚拟-dom，代码实现一下？"><a class="header-anchor" href="#如何把真实-dom-转变为虚拟-dom，代码实现一下？" aria-hidden="true">#</a> 如何把真实 dom 转变为虚拟 dom，代码实现一下？</h2><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">vDom</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> nodeType <span class="token operator">=</span> node<span class="token punctuation">.</span>nodeType\n    <span class="token keyword">let</span> _vnode <span class="token operator">=</span> <span class="token keyword">null</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>nodeType <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token comment">//元素节点</span>\n        <span class="token keyword">let</span> props <span class="token operator">=</span> node<span class="token punctuation">.</span>attributes\n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span>\n        <span class="token keyword">let</span> property <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> props<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            property<span class="token punctuation">[</span>props<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">]</span> <span class="token operator">=</span> props<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>nodeValue\n        <span class="token punctuation">}</span>\n        _vnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VNode</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n            tagName<span class="token operator">:</span> node<span class="token punctuation">.</span>nodeName<span class="token punctuation">,</span>\n            props<span class="token operator">:</span> property<span class="token punctuation">,</span>\n            type<span class="token operator">:</span> nodeType\n        <span class="token punctuation">}</span><span class="token punctuation">)</span>\n        <span class="token keyword">let</span> children <span class="token operator">=</span> node<span class="token punctuation">.</span>childNodes\n        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> children<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token keyword">if</span> <span class="token punctuation">(</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>nodeType <span class="token operator">===</span> <span class="token number">1</span> <span class="token operator">||</span> children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n                _vnode<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span><span class="token function">vDom</span><span class="token punctuation">(</span>children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nodeType <span class="token operator">===</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        _vnode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VNode</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n            type<span class="token operator">:</span> nodeType<span class="token punctuation">,</span>\n            value<span class="token operator">:</span> node<span class="token punctuation">.</span>nodeValue<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n        <span class="token punctuation">}</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> _vnode\n<span class="token punctuation">}</span>\n</code></pre></div>',150);p.render=function(a,t,p,e,c,l){return n(),s("div",null,[o])};export default p;export{t as __pageData};
